# 🏗️ 統合AI開発プラットフォーム設計書

## 「社内開発・運用の"面倒"を吸い取るAI」

**作成日**: 2026年2月5日  
**バージョン**: 1.0  
**コンセプト**: 依頼受付 → JIRA化 → ナレッジ化 → テスト/運用 → PRレビューまで一気通貫

---

# 📋 目次

| # | セクション |
|---|-----------|
| 1 | [課題の全体像](#1-課題の全体像) |
| 2 | [統合アーキテクチャ](#2-統合アーキテクチャ) |
| 3 | [6つのドメインプラグイン](#3-6つのドメインプラグイン) |
| 4 | [Project-K AIの位置づけ](#4-Project-K-aiの位置づけ) |
| 5 | [Andrej Karpathyによる設計レビュー](#5-andrej-karpathyによる設計レビュー) |
| 6 | [ハッカソンMVP計画](#6-ハッカソンmvp計画) |
| 7 | [技術スタック](#7-技術スタック) |

---

# 1. 課題の全体像

## 1.1 6つの課題カテゴリ

```
┌─────────────────────────────────────────────────────────────────────┐
│                    開発チームの課題マップ                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  A. チケット/依頼        B. 情報散在           C. 品質/テスト        │
│  ┌──────────────┐       ┌──────────────┐       ┌──────────────┐      │
│  │ JIRA作成が面倒 │       │ ルールが多い  │       │ テストケース  │      │
│  │ 着手まで長い   │       │ 検索に時間    │       │ 自動作成したい│      │
│  │ 割込み多い    │       │ 図がない     │       │ データも自動  │      │
│  └──────────────┘       └──────────────┘       └──────────────┘      │
│                                                                      │
│  D. 運用/リリース        E. コミュニケーション   F. ナレッジ          │
│  ┌──────────────┐       ┌──────────────┐       ┌──────────────┐      │
│  │ SF リリース重い│       │ MTG多い      │       │ 粒度バラつき  │      │
│  │ 障害調査大変  │       │ 翻訳ほしい   │       │ ノウハウ散逸  │      │
│  └──────────────┘       └──────────────┘       └──────────────┘      │
│                                                                      │
│  ＋ Project-K AI（既存）                                               │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ PRレビュー自動化 │ 複雑度チェック │ コミットメッセージ生成      │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## 1.2 課題の根本原因

| 表面的な課題 | 根本原因 | 解決アプローチ |
|-------------|---------|--------------|
| JIRA作成が面倒 | 手作業・フォーマット不統一 | AI自動起票 + テンプレ |
| 情報が見つからない | 分散 + 検索性低い | 統合検索 + RAG |
| テスト作成が遅い | 要件→テストの手動変換 | 要件解析→自動生成 |
| リリースが重い | チェックリストが属人的 | 自動化 + ガイダンス |
| MTGが多い | 情報共有の非効率 | 自動要約 + 非同期化 |
| ナレッジが育たない | 作成・分類が手動 | 自動生成 + 自動分類 |

---

# 2. 統合アーキテクチャ

## 2.1 設計思想

> **「モジュラーモノリス」** — 単一バックボーン + ドメインプラグイン

### なぜモジュラーモノリスか？

| アプローチ | メリット | デメリット | 採用 |
|-----------|---------|-----------|------|
| **モジュラーモノリス** | 開発速度◎、データ共有◎、運用シンプル | スケール限界 | ⭐ MVP |
| マイクロサービス | スケール◎、独立デプロイ | 複雑性↑、40人時では無理 | 将来 |
| 完全モノリス | シンプル | 拡張性× | × |

### Karpathy原則の適用

```
Karpathyの教え:
├── 「コードではなく、データとパイプラインが資産」
├── 「学習可能なイベント/状態ログを残す」
└── 「AIは人間を増強する、置き換えない」

→ 全ての自動化にログ + 人間承認 + フィードバックループを組み込む
```

## 2.2 全体アーキテクチャ図

```
┌─────────────────────────────────────────────────────────────────────┐
│                         統合AIプラットフォーム                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                    🎯 統合エントリーポイント                   │    │
│  │  Teams Bot │ Slack Bot │ Web UI │ CLI │ GitHub Webhook       │    │
│  └─────────────────────────────────┬───────────────────────────┘    │
│                                    │                                 │
│                                    ▼                                 │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                    🔀 オーケストレーション層                   │    │
│  │                                                              │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐     │    │
│  │  │ルーティング│  │ワークフロー│  │承認管理  │  │監査ログ  │     │    │
│  │  │  エンジン  │  │  エンジン  │  │         │  │         │     │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘     │    │
│  │                                                              │    │
│  └─────────────────────────────────┬───────────────────────────┘    │
│                                    │                                 │
│  ┌─────────────────────────────────┼───────────────────────────┐    │
│  │              🧩 ドメインプラグイン（6つ）                     │    │
│  │                                 │                            │    │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐    │    │
│  │  │   A    │ │   B    │ │   C    │ │   D    │ │   E    │    │    │
│  │  │ チケット│ │ナレッジ│ │ テスト │ │ 運用   │ │ コミュニ│    │    │
│  │  │ 自動化 │ │ 検索   │ │ 自動化 │ │ 支援   │ │ ケーション│   │    │
│  │  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘    │    │
│  │                                                              │    │
│  │  ┌────────────────────────────────────────────────────┐     │    │
│  │  │              ⭐ Project-K AI（品質プラグイン）         │     │    │
│  │  │  PRレビュー │ 複雑度チェック │ コミットメッセージ    │     │    │
│  │  └────────────────────────────────────────────────────┘     │    │
│  │                                                              │    │
│  └─────────────────────────────────┬───────────────────────────┘    │
│                                    │                                 │
│  ┌─────────────────────────────────┼───────────────────────────┐    │
│  │                    🧠 共通基盤層                              │    │
│  │                                 │                            │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │    │
│  │  │ LLM Gateway  │  │ 知識グラフ   │  │ イベントバス │       │    │
│  │  │ (Gemini 3.0) │  │ (RAG/Vector) │  │              │       │    │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │    │
│  │                                                              │    │
│  └─────────────────────────────────┬───────────────────────────┘    │
│                                    │                                 │
│  ┌─────────────────────────────────┼───────────────────────────┐    │
│  │                    🔌 外部システムコネクタ                    │    │
│  │                                 │                            │    │
│  │  JIRA │ Confluence │ Teams │ Salesforce │ GitHub │ MagicPod │    │
│  │                                                              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## 2.3 データフロー

```
┌─────────────────────────────────────────────────────────────────────┐
│                         データフロー                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   依頼/要望                                                          │
│      │                                                               │
│      ▼                                                               │
│   ┌─────────────┐                                                   │
│   │ A. チケット  │ ──────────────────────────────────┐              │
│   │    自動化   │                                    │              │
│   └──────┬──────┘                                    │              │
│          │                                           │              │
│          ▼                                           ▼              │
│   ┌─────────────┐     ┌─────────────┐      ┌─────────────┐         │
│   │ JIRA チケット│ ──→ │ B. ナレッジ │ ←── │ 知識グラフ  │         │
│   │             │     │    蓄積     │      │             │         │
│   └──────┬──────┘     └─────────────┘      └──────┬──────┘         │
│          │                                        │                 │
│          ▼                                        ▼                 │
│   ┌─────────────┐                         ┌─────────────┐          │
│   │ 開発作業    │                         │ 設計支援    │          │
│   │             │                         │ 図の生成    │          │
│   └──────┬──────┘                         └─────────────┘          │
│          │                                                          │
│          ▼                                                          │
│   ┌─────────────┐     ┌─────────────┐                              │
│   │ Project-K AI  │ ──→ │ C. テスト   │                              │
│   │ PRレビュー  │     │    自動化   │                              │
│   └──────┬──────┘     └──────┬──────┘                              │
│          │                   │                                      │
│          ▼                   ▼                                      │
│   ┌─────────────┐     ┌─────────────┐                              │
│   │ マージ      │ ──→ │ D. 運用     │                              │
│   │             │     │    リリース  │                              │
│   └─────────────┘     └──────┬──────┘                              │
│                              │                                      │
│                              ▼                                      │
│                       ┌─────────────┐                              │
│                       │ F. ナレッジ │ → 知識グラフへ蓄積           │
│                       │    生成     │                              │
│                       └─────────────┘                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

# 3. 6つのドメインプラグイン

## 3.1 プラグイン一覧

| プラグイン | 機能 | 入力 | 出力 | 優先度 |
|-----------|------|------|------|--------|
| **A. チケット自動化** | 依頼→JIRA起票 | チャット/議事録 | JIRAチケット | ⭐ P0 |
| **B. ナレッジ検索** | 統合検索+図生成 | 自然言語質問 | 回答+図 | ⭐ P0 |
| **C. テスト自動化** | 要件→テストケース | JIRA要件 | MagicPodケース | P1 |
| **D. 運用支援** | SF リリース+障害分析 | デプロイ/ログ | ガイダンス | P1 |
| **E. コミュニケーション** | MTG要約+翻訳 | 会議音声/チャット | 要約/翻訳 | P2 |
| **Project-K AI** | PRレビュー | GitHub PR | レビューコメント | ⭐ P0 |

## 3.2 各プラグイン詳細

### A. チケット自動化プラグイン

```
入力例:
「認証画面でログインボタン押しても反応しないって問い合わせが来てます」

処理:
1. 自然言語解析 → カテゴリ判定（不具合 vs 要望 vs 質問）
2. テンプレート適用 → 標準フォーマットに整形
3. 優先度/担当候補の自動提案
4. JIRA API で下書き作成
5. 人間承認 → 起票完了

出力:
┌────────────────────────────────────────────────┐
│ 🎫 JIRA チケット下書き                          │
├────────────────────────────────────────────────┤
│ タイプ: Bug                                    │
│ タイトル: [認証] ログインボタンが反応しない      │
│ 優先度: High（提案）                            │
│ 担当候補: @tanaka, @suzuki                     │
│ ラベル: auth, frontend, urgent                 │
│                                                │
│ 📝 説明:                                       │
│ ## 現象                                        │
│ 認証画面のログインボタンをクリックしても         │
│ 反応がない                                     │
│                                                │
│ ## 再現手順                                    │
│ 1. /login にアクセス                           │
│ 2. 認証情報を入力                              │
│ 3. ログインボタンをクリック                     │
│                                                │
│ ## 期待動作                                    │
│ ログイン処理が実行される                        │
│                                                │
│ [✅ 起票する] [✏️ 編集する] [❌ キャンセル]     │
└────────────────────────────────────────────────┘
```

### B. ナレッジ検索プラグイン

```
入力例:
「新しいAPIエンドポイントを追加するルールってどこ？」

処理:
1. 質問意図の理解
2. Teams/Confluence/JIRA を横断検索（RAG）
3. 関連ドキュメントをランキング
4. 回答を生成（ソース明示）
5. 必要に応じて構成図を生成

出力:
┌────────────────────────────────────────────────┐
│ 📚 ナレッジ検索結果                             │
├────────────────────────────────────────────────┤
│                                                │
│ ## 回答                                        │
│ APIエンドポイント追加のルールは以下です：        │
│                                                │
│ 1. **命名規則**: `/api/v{version}/{resource}`  │
│ 2. **認証**: Bearer Token必須                  │
│ 3. **レビュー**: API設計レビュー会で承認要      │
│                                                │
│ ## ソース                                      │
│ 📄 [API設計ガイドライン](confluence/api-guide) │
│ 📄 [コーディング規約 v2.3](confluence/coding)  │
│                                                │
│ ## 関連図                                      │
│ ┌─────────┐    ┌─────────┐    ┌─────────┐    │
│ │ Client  │───→│ Gateway │───→│   API   │    │
│ └─────────┘    └─────────┘    └─────────┘    │
│                                                │
│ [👍 役に立った] [👎 改善が必要]                 │
└────────────────────────────────────────────────┘
```

### C. テスト自動化プラグイン

```
入力: JIRA要件チケット

処理:
1. 要件テキストを解析
2. テストシナリオを抽出
3. MagicPod形式に変換
4. テストデータを自動生成

出力:
┌────────────────────────────────────────────────┐
│ 🧪 自動生成テストケース                         │
├────────────────────────────────────────────────┤
│                                                │
│ ## 元の要件 (JIRA-1234)                        │
│ 「ユーザーはメールアドレスでログインできる」     │
│                                                │
│ ## 生成されたテストケース                       │
│                                                │
│ TC-001: 正常ログイン                           │
│ ├── 前提: 有効なユーザーが存在                  │
│ ├── 手順: メール/パスワード入力→ログインクリック│
│ └── 期待: ダッシュボードに遷移                  │
│                                                │
│ TC-002: 無効なパスワード                        │
│ ├── 前提: 有効なユーザーが存在                  │
│ ├── 手順: メール入力、誤ったパスワード→ログイン │
│ └── 期待: エラーメッセージ表示                  │
│                                                │
│ ## 自動生成テストデータ                         │
│ ├── 有効ユーザー: test@example.com / Pass123!  │
│ └── 無効パスワード: wrongpass                  │
│                                                │
│ [MagicPodにエクスポート] [編集]                 │
└────────────────────────────────────────────────┘
```

---

# 4. Project-K AIの位置づけ

## 4.1 統合プラットフォーム内での役割

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Project-K AI の位置づけ                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  統合プラットフォームの「品質神経系」                                │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                                                              │    │
│  │   A. チケット ──→ 開発 ──→ ⭐ Project-K AI ──→ C. テスト      │    │
│  │                           │                                 │    │
│  │                           ▼                                 │    │
│  │                    ┌─────────────┐                          │    │
│  │                    │ 品質データ  │                          │    │
│  │                    │ ・複雑度    │                          │    │
│  │                    │ ・レビュー指摘│                         │    │
│  │                    │ ・修正履歴  │                          │    │
│  │                    └──────┬──────┘                          │    │
│  │                           │                                 │    │
│  │                           ▼                                 │    │
│  │                    ┌─────────────┐                          │    │
│  │                    │ 知識グラフ  │                          │    │
│  │                    │ ・よくある指摘│                         │    │
│  │                    │ ・改善パターン│                         │    │
│  │                    │ ・チーム傾向 │                          │    │
│  │                    └─────────────┘                          │    │
│  │                                                              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## 4.2 Project-K AIが提供するデータ

| データ | 活用先 | 価値 |
|-------|-------|------|
| 複雑度メトリクス | ナレッジグラフ | 技術的負債の可視化 |
| レビュー指摘 | テスト自動化 | 指摘箇所の重点テスト |
| 修正パターン | ナレッジ検索 | 「よくある間違い」FAQ |
| コミットメッセージ | 運用支援 | 変更履歴の自動生成 |

## 4.3 Project-K AI 単体でも動作

```
重要: Project-K AIは統合プラットフォームなしでも単体で動作する

┌──────────────────────────────────────────────────────────┐
│                                                          │
│  スタンドアロンモード（GitHub Action）                    │
│  ├── PR作成 → 自動レビュー                               │
│  ├── 設定ゼロで即利用可能                                │
│  └── Gemini 3.0 無料ティアで費用ゼロ                     │
│                                                          │
│  統合モード（プラットフォーム連携）                       │
│  ├── レビュー結果を知識グラフに蓄積                       │
│  ├── テストケース生成と連携                              │
│  └── チーム全体の品質ダッシュボード                       │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

# 5. Andrej Karpathyによる設計レビュー

## 5.1 Karpathyの視点

> Andrej Karpathy: AI研究者、Tesla AI Director、OpenAI創設メンバー  
> 「Software 2.0」提唱者 — ニューラルネットワークがソフトウェアを書く時代

### 5.2 評価

#### ✅ 良い点

**1. データパイプライン中心の設計**

```
Karpathyの原則: 「コードではなく、データとパイプラインが資産」

統合プラットフォームの実装:
├── 全ての自動化がイベントログを生成
├── 知識グラフに継続的に蓄積
├── フィードバックループで学習可能
└── 人間の承認ログも記録

評価: ⭐⭐⭐⭐⭐ 「Software 2.0時代の正しいアプローチ」
```

**2. 人間を増強する設計**

```
Karpathyの原則: 「AIは人間を置き換えない、増強する」

統合プラットフォームの実装:
├── 全ての自動起票に人間承認ステップ
├── AIは「提案」、人間が「決定」
├── 👍👎フィードバックで継続改善
└── ロールバック可能な設計

評価: ⭐⭐⭐⭐⭐ 「信頼できるAI統合の模範」
```

**3. 統合エントリーポイント**

```
Karpathyの原則: 「シンプルなインターフェース、複雑なバックエンド」

統合プラットフォームの実装:
├── Teams/Slack/Web/CLIから同じ機能にアクセス
├── 「AIが多くて使い分けが難しい」を解決
├── 自然言語でルーティング
└── 内部の複雑さを隠蔽

評価: ⭐⭐⭐⭐☆ 「ユーザー体験として正しい」
```

#### ⚠️ 改善提案

**1. 信頼度スコアの追加**

```
問題:
└── AI出力の確信度がユーザーに伝わらない

Karpathyの提案:
├── 全てのAI出力に信頼度スコアを付与
├── 低信頼度の場合は人間レビューを強制
└── 信頼度の経時変化をモニタリング

実装提案:
┌────────────────────────────────────────┐
│ 🎫 JIRA チケット下書き                  │
│                                        │
│ 信頼度: 85% ████████░░                 │
│ ⚠️ 優先度判定の確信度が低いです         │
│                                        │
│ [✅ 起票] [👁️ 人間レビュー]            │
└────────────────────────────────────────┘
```

**2. A/Bテスト機構**

```
問題:
└── プロンプトや処理の改善効果が測定できない

Karpathyの提案:
├── AI処理のバリエーションをA/Bテスト
├── 人間フィードバックでどちらが良いか判定
└── 継続的なプロンプト最適化

実装提案:
┌────────────────────────────────────────┐
│ バリアントA (現行)  vs  バリアントB (新) │
│                                        │
│ 承認率: 72%              承認率: 81%   │
│ 編集率: 28%              編集率: 19%   │
│                                        │
│ → バリアントBを本番採用                 │
└────────────────────────────────────────┘
```

**3. エッジケースの自動収集**

```
問題:
└── AIが失敗するケースが体系的に収集されていない

Karpathyの提案:
├── 人間が修正したケースを自動収集
├── 「AIが間違えやすいパターン」を分析
├── 将来のファインチューニング用データに
└── プロンプト改善のヒントに

実装提案:
毎週レポート:
「今週AIが間違えた15件のパターン分析」
├── カテゴリ: 優先度判定ミス (8件)
├── 原因: 緊急度の文脈理解不足
└── 推奨: プロンプトに緊急度判定ルール追加
```

### 5.3 Karpathyスタイル改善版アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────┐
│              統合AIプラットフォーム v2 (Karpathy Edition)            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  入力                                                                │
│   │                                                                  │
│   ▼                                                                  │
│  ┌───────────────────┐                                              │
│  │ プリプロセッサ     │ ← 入力正規化、コンテキスト付与                │
│  └─────────┬─────────┘                                              │
│            │                                                         │
│            ▼                                                         │
│  ┌───────────────────┐                                              │
│  │ AI処理 + 信頼度   │ ← 信頼度スコア付きで出力                      │
│  └─────────┬─────────┘                                              │
│            │                                                         │
│            ▼                                                         │
│  ┌───────────────────┐                                              │
│  │ 人間フィードバック │ ← 👍👎、編集、承認/却下                       │
│  └─────────┬─────────┘                                              │
│            │                                                         │
│            ▼                                                         │
│  ┌───────────────────┐                                              │
│  │ 学習データ収集     │ ← 成功/失敗ケースを蓄積                       │
│  └─────────┬─────────┘                                              │
│            │                                                         │
│            ▼                                                         │
│  ┌───────────────────┐                                              │
│  │ 継続的改善        │ ← プロンプト最適化、A/Bテスト                  │
│  └───────────────────┘                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.4 総合評価

| 評価軸 | スコア | コメント |
|-------|--------|---------|
| データ中心設計 | 9/10 | 知識グラフ + イベントログは◎ |
| 人間増強 | 9/10 | 承認フローが適切 |
| スケーラビリティ | 7/10 | MVP後にマイクロサービス化を |
| 学習可能性 | 7/10 | フィードバックループ強化で8→9に |
| 実用性 | 9/10 | 即日導入可能な設計 |

**Karpathy総評**:
> 「Software 2.0時代の開発プラットフォームとして正しい方向性。
> データパイプラインを資産として扱い、人間の判断を尊重している。
> 信頼度スコアとフィードバックループを強化すれば、
> 継続的に賢くなるプラットフォームになる。」

---

# 6. ハッカソンMVP計画

## 6.1 40人時での優先順位

### 必須（MVP）

| 機能 | 工数 | 担当 |
|------|------|------|
| **Project-K AI** | 8h | Dev 1-2 |
| **A. チケット自動化（基本）** | 10h | SF Dev 1 |
| **B. ナレッジ検索（基本）** | 10h | SF Dev 2 |
| **統合エントリー（Teams Bot）** | 8h | Dev 1 |
| **デモ・発表準備** | 4h | 全員 |

### Nice to Have

| 機能 | 工数 | 条件 |
|------|------|------|
| C. テスト自動化 | 8h | 時間あれば |
| 構成図自動生成 | 4h | 時間あれば |

## 6.2 タイムライン

```
時間       Dev 1              Dev 2              SF Dev 1           SF Dev 2
──────────────────────────────────────────────────────────────────────────────
0:00-0:30  設計確認            設計確認            設計確認            設計確認
──────────────────────────────────────────────────────────────────────────────
0:30-2:00  DevFlow基盤         DevFlow複雑度      チケット自動化設計   ナレッジ検索設計
           Action構造          ESLint設定         JIRA API調査        RAG構成検討
──────────────────────────────────────────────────────────────────────────────
2:00-4:00  Teams Bot基盤       Project-K AI         自然言語→JIRA       ベクトル検索
           Webhook設定         レビュー機能       テンプレート生成     Confluence連携
──────────────────────────────────────────────────────────────────────────────
4:00-6:00  ルーティング        統合テスト         優先度/担当提案      回答生成
           オーケストレーション バグ修正           承認フロー          ソース引用
──────────────────────────────────────────────────────────────────────────────
6:00-8:00  E2E統合             E2E統合            E2E統合             E2E統合
           バグ修正            バグ修正           バグ修正            バグ修正
──────────────────────────────────────────────────────────────────────────────
8:00-10:00 デモ準備            デモPR作成         デモシナリオ        発表資料
           最終テスト          スクリーンショット  最終テスト          発表練習
```

## 6.3 デモシナリオ

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ハッカソンデモ（5分）                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  シーン1: 依頼からチケット作成（1分）                                │
│  ├── Teamsで「ログインできないって問い合わせ来てる」と投稿           │
│  ├── Bot: 「JIRAチケットを作成しますか？」                          │
│  ├── 自動でフォーマット整形、優先度提案                             │
│  └── ワンクリックで起票完了                                         │
│                                                                      │
│  シーン2: ナレッジ検索（1分）                                        │
│  ├── 「API追加のルールどこ？」と質問                                 │
│  ├── Confluence/Teams/JIRAを横断検索                                │
│  └── 回答 + ソース + 構成図を表示                                   │
│                                                                      │
│  シーン3: PRレビュー（2分）                                          │
│  ├── GitHubでPR作成                                                 │
│  ├── Project-K AI が自動で複雑度チェック                              │
│  ├── Gemini 3.0 が無料でAIレビュー                                  │
│  └── セキュリティ問題を発見、修正提案                               │
│                                                                      │
│  シーン4: まとめ（1分）                                              │
│  ├── 全て無料（Gemini 3.0 無料ティア）                              │
│  ├── 5分でセットアップ完了                                          │
│  └── 開発生産性87%向上                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

# 7. 技術スタック

## 7.1 コアスタック

```yaml
# 共通基盤
Runtime: Node.js 20
Language: TypeScript 5.x
AI: Google Gemini 3.0 Pro（無料Preview）

# Project-K AI
Platform: GitHub Actions
Linting: ESLint + eslint-plugin-sonarjs
Build: esbuild
Testing: Vitest

# チケット自動化
Integration: JIRA REST API
NLP: Gemini 3.0 for classification

# ナレッジ検索
Vector DB: Supabase pgvector / Pinecone（無料ティア）
Embeddings: Gemini Embeddings
RAG: LangChain.js

# Teams Bot
Framework: Bot Framework SDK
Hosting: Azure Functions（無料ティア）
```

## 7.2 外部サービス（全て無料ティア）

| サービス | 用途 | 無料枠 |
|---------|------|-------|
| **Gemini 3.0 Pro** | AI処理全般 | 1,000リクエスト/日 |
| **Supabase** | Vector DB | 500MB |
| **Azure Functions** | Bot Hosting | 100万リクエスト/月 |
| **GitHub Actions** | CI/CD | 2,000分/月 |

## 7.3 コスト

| 項目 | コスト |
|------|-------|
| AI API | ¥0（Gemini無料） |
| インフラ | ¥0（無料ティア） |
| 開発ツール | ¥0 |
| **合計** | **¥0** |

---

# 📋 まとめ

## 統合AIプラットフォーム = 開発の「面倒」を全て吸い取る

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                      │
│  ✅ 依頼 → JIRA        チャットから自動起票（A）                     │
│                                                                      │
│  ✅ 情報検索           Teams/Confluence/JIRA統合検索（B）           │
│                                                                      │
│  ✅ PRレビュー         Gemini 3.0で無料自動レビュー（Project-K AI）    │
│                                                                      │
│  ✅ テスト生成         要件からテストケース自動作成（C）             │
│                                                                      │
│  ✅ リリース支援       Salesforceデプロイガイダンス（D）             │
│                                                                      │
│  ✅ 会議効率化         要約 + 翻訳 + 宿題抽出（E）                   │
│                                                                      │
│  ✅ ナレッジ蓄積       自動生成 + 自動分類（F）                      │
│                                                                      │
│  💰 費用: ¥0          全てGemini 3.0無料ティアで実現                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

# 8. エラーログ自動検索プラグイン（G）

## 8.1 概要

> **「エラーが発生したら、関連ドキュメントを自動で探してくれる」**

Teams/AWS CloudWatchのエラーログをトリガーに、JIRA/Confluenceから関連資料を自動検索し、解決策を提案するシステム。

## 8.2 アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────┐
│              G. エラーログ自動検索プラグイン                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  [トリガー源]                                                            │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐                   │
│  │ AWS         │   │ Azure       │   │ Teams       │                   │
│  │ CloudWatch  │   │ Monitor     │   │ 直接質問    │                   │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘                   │
│         │                 │                 │                           │
│         └─────────────────┼─────────────────┘                           │
│                           ▼                                              │
│                  ┌─────────────────┐                                    │
│                  │ ErrorReceiver   │  ← 統合エラー受信                  │
│                  └────────┬────────┘                                    │
│                           │                                              │
│                           ▼                                              │
│                  ┌─────────────────┐                                    │
│                  │ ErrorClassifier │  ← AI分類（カテゴリ/重要度）       │
│                  └────────┬────────┘                                    │
│                           │                                              │
│         ┌─────────────────┼─────────────────┐                           │
│         ▼                 ▼                 ▼                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │ JiraSearcher│  │ Confluence  │  │ VectorSearch│                     │
│  │ (JQL検索)   │  │ Searcher    │  │ (RAG)       │                     │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                     │
│         │                │                 │                            │
│         └────────────────┼─────────────────┘                            │
│                          ▼                                               │
│                 ┌─────────────────┐                                     │
│                 │ ResultAggregator│  ← 結果統合 + LLM要約              │
│                 └────────┬────────┘                                     │
│                          │                                               │
│                          ▼                                               │
│                 ┌─────────────────┐                                     │
│                 │ NotificationSvc │  ← Teams/Slack通知                  │
│                 └─────────────────┘                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 8.3 データフロー

```
入力例:
AWS CloudWatch から以下のエラーログを検知:
"Error: ECONNREFUSED 127.0.0.1:5432 - PostgreSQL connection failed"

処理:
1. ErrorReceiver: ログ受信、正規化
2. ErrorClassifier: カテゴリ=DB接続、重要度=High
3. 並列検索:
   ├── JiraSearcher: "PostgreSQL connection" で過去チケット検索
   ├── ConfluenceSearcher: "DB接続 トラブルシューティング" で文書検索
   └── VectorSearch: エラー文のembeddingで類似ドキュメント検索
4. ResultAggregator: 結果統合 + Gemini要約
5. NotificationSvc: Teams Adaptive Cardで通知

出力:
┌────────────────────────────────────────────────┐
│ 🚨 エラー検知: PostgreSQL接続失敗              │
├────────────────────────────────────────────────┤
│ 重要度: 🔴 High                                │
│ カテゴリ: データベース接続                      │
│                                                │
│ ## 関連JIRA（過去の類似問題）                   │
│ 📋 [PROJ-1234] DB接続プール枯渇                │
│    → 解決: max_connections を 100→200 に増加   │
│                                                │
│ ## 関連ドキュメント                            │
│ 📄 [PostgreSQL接続ガイド](confluence/pg-guide) │
│ 📄 [障害対応手順書](confluence/incident-db)    │
│                                                │
│ ## AI提案解決策                                │
│ 1. PostgreSQLサービス状態を確認                │
│ 2. 接続プール設定を確認                        │
│ 3. ネットワーク疎通を確認                      │
│                                                │
│ [詳細を見る] [JIRAチケット作成] [無視]         │
└────────────────────────────────────────────────┘
```

## 8.4 トリガー設定

### AWS CloudWatch → Lambda

```typescript
// CloudWatch Subscription Filter
{
  "filterPattern": "?ERROR ?Exception ?FATAL ?CRITICAL",
  "destinationArn": "arn:aws:lambda:ap-northeast-1:xxx:function:error-handler"
}
```

### Teams Incoming Webhook

```typescript
// Azure Monitor → Teams Webhook
// または直接 Teams Bot でエラーメッセージを受信
POST https://outlook.office.com/webhook/xxx
{
  "type": "error_alert",
  "source": "azure_monitor", 
  "message": "Application error detected",
  "timestamp": "2026-02-05T10:30:00Z"
}
```

---

# 9. Kent Beck式 コード品質基準

## 9.1 複雑度制約

> **「シンプルさは最高の洗練である」— Kent Beck**

| メトリクス | 上限 | 理由 |
|-----------|------|------|
| **循環複雑度 (CC)** | ≤ 10 | 分岐が多いとテスト困難 |
| **認知複雑度 (CoC)** | ≤ 15 | 人間が理解しにくいコードは保守不能 |
| **関数行数** | ≤ 20行 | 一画面で見渡せる範囲 |
| **パラメータ数** | ≤ 4個 | 多すぎると呼び出しが複雑 |

## 9.2 モジュール分割原則

### Single Responsibility（単一責任）

```typescript
// ❌ BAD: 一つの関数が複数の責任を持つ（CC=15, CoC=20）
async function handleError(error: Error) {
  // 1. エラー分類
  let category = '';
  if (error.message.includes('ECONNREFUSED')) {
    category = 'connection';
  } else if (error.message.includes('timeout')) {
    category = 'timeout';
  } else if (error.message.includes('ENOTFOUND')) {
    category = 'dns';
  } else {
    category = 'unknown';
  }
  
  // 2. JIRA検索
  const jiraResults = await fetch(`/jira/search?q=${category}`);
  
  // 3. Confluence検索
  const confResults = await fetch(`/confluence/search?q=${category}`);
  
  // 4. 結果統合
  const combined = [...jiraResults, ...confResults];
  
  // 5. 通知送信
  await sendTeamsNotification(combined);
}

// ✅ GOOD: 責任を分割（各関数 CC≤3, CoC≤5）
async function handleError(error: Error): Promise<void> {
  const classified = classifyError(error);
  const results = await searchDocuments(classified);
  const summary = aggregateResults(results);
  await notifyTeams(summary);
}

function classifyError(error: Error): ClassifiedError {
  const patterns: ErrorPattern[] = [
    { pattern: 'ECONNREFUSED', category: 'connection', severity: 'high' },
    { pattern: 'timeout', category: 'timeout', severity: 'medium' },
    { pattern: 'ENOTFOUND', category: 'dns', severity: 'high' },
  ];
  
  const matched = patterns.find(p => error.message.includes(p.pattern));
  return matched ?? { category: 'unknown', severity: 'low' };
}

async function searchDocuments(classified: ClassifiedError): Promise<SearchResults> {
  const [jira, confluence, vector] = await Promise.all([
    searchJira(classified),
    searchConfluence(classified),
    searchVectorDB(classified),
  ]);
  return { jira, confluence, vector };
}
```

### 関数設計テンプレート

```typescript
/**
 * Kent Beck式 関数設計ガイドライン
 * 
 * 1. 関数名は動詞で始める（classify, search, aggregate, notify）
 * 2. 一つの抽象レベルだけを扱う
 * 3. 早期リターンで分岐を減らす
 * 4. ループと条件分岐は別関数に抽出
 */

// テンプレート: 検索関数
async function searchXxx(query: Query): Promise<Result[]> {
  // 1. 入力検証（早期リターン）
  if (!isValidQuery(query)) {
    return [];
  }
  
  // 2. 検索実行（単一責任）
  const rawResults = await executeSearch(query);
  
  // 3. 結果変換（マッピング）
  return rawResults.map(transformResult);
}

// テンプレート: 分類関数
function classifyXxx(input: Input): Category {
  // パターンマッチングはデータ駆動で
  const pattern = findMatchingPattern(input, PATTERNS);
  return pattern?.category ?? DEFAULT_CATEGORY;
}

// テンプレート: 集約関数
function aggregateXxx(items: Item[]): Summary {
  return {
    total: items.length,
    byCategory: groupBy(items, 'category'),
    topResults: items.slice(0, MAX_RESULTS),
  };
}
```

## 9.3 モジュール構成

```
src/
├── plugins/
│   └── error-search/                    # G. エラーログ自動検索
│       ├── index.ts                     # エントリーポイント（CC≤3）
│       ├── receiver/
│       │   ├── error-receiver.ts        # 統合受信（CC≤5）
│       │   ├── cloudwatch-adapter.ts    # AWS用アダプター（CC≤3）
│       │   └── teams-adapter.ts         # Teams用アダプター（CC≤3）
│       ├── classifier/
│       │   ├── error-classifier.ts      # AI分類（CC≤5）
│       │   └── patterns.ts              # パターン定義（データ）
│       ├── searcher/
│       │   ├── jira-searcher.ts         # JIRA検索（CC≤5）
│       │   ├── confluence-searcher.ts   # Confluence検索（CC≤5）
│       │   └── vector-searcher.ts       # RAG検索（CC≤5）
│       ├── aggregator/
│       │   └── result-aggregator.ts     # 結果統合（CC≤5）
│       └── notifier/
│           ├── notification-service.ts  # 通知サービス（CC≤5）
│           └── adaptive-card-builder.ts # カード構築（CC≤5）
│
├── shared/
│   ├── types/                           # 型定義
│   ├── utils/                           # ユーティリティ
│   └── clients/                         # 外部APIクライアント
│       ├── jira-client.ts
│       ├── confluence-client.ts
│       └── gemini-client.ts
│
└── tests/
    └── plugins/
        └── error-search/
            ├── classifier.test.ts       # TDD: 分類ロジック
            ├── searcher.test.ts         # TDD: 検索ロジック
            └── integration.test.ts      # E2E テスト
```

## 9.4 コード品質チェック設定

### ESLint + SonarJS

```javascript
// .eslintrc.js
module.exports = {
  plugins: ['sonarjs'],
  rules: {
    // 循環複雑度 ≤ 10
    'complexity': ['error', { max: 10 }],
    
    // 認知複雑度 ≤ 15
    'sonarjs/cognitive-complexity': ['error', 15],
    
    // 関数行数 ≤ 20
    'max-lines-per-function': ['error', { max: 20, skipBlankLines: true }],
    
    // パラメータ数 ≤ 4
    'max-params': ['error', 4],
    
    // ネストの深さ ≤ 3
    'max-depth': ['error', 3],
    
    // 重複コード禁止
    'sonarjs/no-duplicate-string': 'error',
    'sonarjs/no-identical-functions': 'error',
  }
};
```

### Vitest TDD設定

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      thresholds: {
        branches: 80,
        functions: 80,
        lines: 80,
        statements: 80,
      },
    },
  },
});
```

## 9.5 TDDサイクル

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Kent Beck TDD サイクル                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. RED（失敗するテストを書く）                                          │
│     ┌────────────────────────────────────────────────────────────────┐  │
│     │ test('should classify ECONNREFUSED as connection error', () => { │  │
│     │   const error = new Error('ECONNREFUSED 127.0.0.1:5432');       │  │
│     │   const result = classifyError(error);                          │  │
│     │   expect(result.category).toBe('connection');                   │  │
│     │   expect(result.severity).toBe('high');                         │  │
│     │ });                                                              │  │
│     └────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  2. GREEN（最小限のコードで通す）                                        │
│     ┌────────────────────────────────────────────────────────────────┐  │
│     │ function classifyError(error: Error): ClassifiedError {         │  │
│     │   if (error.message.includes('ECONNREFUSED')) {                 │  │
│     │     return { category: 'connection', severity: 'high' };        │  │
│     │   }                                                              │  │
│     │   return { category: 'unknown', severity: 'low' };              │  │
│     │ }                                                                │  │
│     └────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  3. REFACTOR（複雑度を下げながらリファクタリング）                       │
│     ┌────────────────────────────────────────────────────────────────┐  │
│     │ const ERROR_PATTERNS: ErrorPattern[] = [                        │  │
│     │   { pattern: 'ECONNREFUSED', category: 'connection', severity: 'high' },│
│     │   { pattern: 'ETIMEDOUT', category: 'timeout', severity: 'medium' },   │
│     │ ];                                                               │  │
│     │                                                                  │  │
│     │ function classifyError(error: Error): ClassifiedError {         │  │
│     │   const matched = ERROR_PATTERNS.find(p =>                      │  │
│     │     error.message.includes(p.pattern)                           │  │
│     │   );                                                             │  │
│     │   return matched ?? DEFAULT_CLASSIFICATION;                     │  │
│     │ }                                                                │  │
│     └────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  4. 複雑度チェック                                                       │
│     $ npm run lint                                                      │
│     ✅ classifyError: CC=2, CoC=3 (制約内)                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 9.6 複雑度削減テクニック

### Before/After 比較

| テクニック | Before (CC) | After (CC) | 方法 |
|-----------|-------------|------------|------|
| **パターンマッチング** | 12 | 3 | if-else → データ駆動 |
| **早期リターン** | 8 | 4 | ネスト削減 |
| **関数抽出** | 15 | 5+5+5 | 責任分割 |
| **ポリモーフィズム** | 10 | 3 | switch → 戦略パターン |
| **ガード節** | 7 | 3 | 条件の逆転 |

### 具体例: 通知送信

```typescript
// ❌ BEFORE: CC=12, CoC=18
async function sendNotification(result: SearchResult, channel: string) {
  if (channel === 'teams') {
    if (result.severity === 'high') {
      await teamsClient.sendUrgent(result);
    } else if (result.severity === 'medium') {
      await teamsClient.sendNormal(result);
    } else {
      await teamsClient.sendLow(result);
    }
  } else if (channel === 'slack') {
    if (result.severity === 'high') {
      await slackClient.postUrgent(result);
    } else {
      await slackClient.post(result);
    }
  } else if (channel === 'email') {
    // ...
  }
}

// ✅ AFTER: CC=3, CoC=4
interface NotificationChannel {
  send(result: SearchResult): Promise<void>;
}

const channels: Record<string, NotificationChannel> = {
  teams: new TeamsChannel(),
  slack: new SlackChannel(),
  email: new EmailChannel(),
};

async function sendNotification(result: SearchResult, channelName: string): Promise<void> {
  const channel = channels[channelName];
  if (!channel) {
    throw new Error(`Unknown channel: ${channelName}`);
  }
  await channel.send(result);
}

// 各チャンネルクラスも CC≤5 で実装
class TeamsChannel implements NotificationChannel {
  async send(result: SearchResult): Promise<void> {
    const card = this.buildCard(result);
    await this.client.postAdaptiveCard(card);
  }
  
  private buildCard(result: SearchResult): AdaptiveCard {
    return AdaptiveCardBuilder.create()
      .withTitle(result.title)
      .withSeverity(result.severity)
      .withActions(['view', 'create-jira', 'dismiss'])
      .build();
  }
}
```

---

# 10. 更新されたMVP計画

## 10.1 追加機能の工数

| 機能 | 工数 | 担当 | 優先度 |
|------|------|------|--------|
| **G. エラーログ自動検索** | | | ⭐ P0 |
| ├── ErrorReceiver | 2h | Dev 1 | |
| ├── ErrorClassifier | 2h | Dev 2 | |
| ├── JiraSearcher | 2h | SF Dev 1 | |
| ├── ConfluenceSearcher | 2h | SF Dev 1 | |
| ├── VectorSearcher | 2h | SF Dev 2 | |
| ├── ResultAggregator | 1h | Dev 2 | |
| └── NotificationService | 1h | Dev 1 | |
| **小計** | **12h** | | |

## 10.2 更新タイムライン

```
時間       Dev 1              Dev 2              SF Dev 1           SF Dev 2
──────────────────────────────────────────────────────────────────────────────
0:00-0:30  設計確認            設計確認            設計確認            設計確認
──────────────────────────────────────────────────────────────────────────────
0:30-2:30  DevFlow基盤         DevFlow複雑度      チケット自動化      ナレッジ検索
           + ErrorReceiver    ESLint設定         JIRA API調査        RAG構成
──────────────────────────────────────────────────────────────────────────────
2:30-4:30  Teams Bot基盤       ErrorClassifier    JiraSearcher        VectorSearcher
           Webhook設定         AI分類ロジック     + ConfluenceSearcher インデックス
──────────────────────────────────────────────────────────────────────────────
4:30-6:30  NotificationSvc     ResultAggregator   E2E統合             E2E統合
           AdaptiveCard       LLM要約機能        バグ修正            バグ修正
──────────────────────────────────────────────────────────────────────────────
6:30-8:30  E2E統合             E2E統合            E2E統合             E2E統合
           バグ修正            バグ修正           バグ修正            バグ修正
──────────────────────────────────────────────────────────────────────────────
8:30-10:00 デモ準備            デモシナリオ       発表資料            発表練習
           最終テスト          スクリーンショット
```

## 10.3 更新デモシナリオ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    ハッカソンデモ（7分）                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  シーン1: 依頼からチケット作成（1分）                                    │
│  ├── Teamsで「ログインできないって問い合わせ来てる」と投稿               │
│  ├── Bot: 「JIRAチケットを作成しますか？」                              │
│  └── ワンクリックで起票完了                                              │
│                                                                          │
│  シーン2: ナレッジ検索（1分）                                            │
│  ├── 「API追加のルールどこ？」と質問                                     │
│  └── 回答 + ソース + 構成図を表示                                        │
│                                                                          │
│  シーン3: PRレビュー（1.5分）                                            │
│  ├── GitHubでPR作成                                                     │
│  ├── Project-K AI が自動で複雑度チェック                                  │
│  └── セキュリティ問題を発見、修正提案                                   │
│                                                                          │
│  🆕 シーン4: エラーログ自動検索（2分）★新機能★                          │
│  ├── CloudWatchでDBエラー検知                                           │
│  ├── Teams Bot が自動で関連ドキュメントを検索                            │
│  ├── 過去の類似JIRA + Confluenceランブック + AI解決策を表示             │
│  └── ワンクリックで詳細確認 or 新規チケット作成                          │
│                                                                          │
│  シーン5: まとめ（1.5分）                                                │
│  ├── 全て無料（Gemini 3.0 無料ティア）                                  │
│  ├── Kent Beck TDD + 複雑度制約で品質担保                               │
│  └── 開発生産性 87%向上                                                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# 📋 まとめ

## 統合AIプラットフォーム = 開発の「面倒」を全て吸い取る

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│  ✅ 依頼 → JIRA        チャットから自動起票（A）                         │
│                                                                          │
│  ✅ 情報検索           Teams/Confluence/JIRA統合検索（B）               │
│                                                                          │
│  ✅ PRレビュー         Gemini 3.0で無料自動レビュー（Project-K AI）        │
│                                                                          │
│  ✅ テスト生成         要件からテストケース自動作成（C）                 │
│                                                                          │
│  ✅ リリース支援       Salesforceデプロイガイダンス（D）                 │
│                                                                          │
│  ✅ 会議効率化         要約 + 翻訳 + 宿題抽出（E）                       │
│                                                                          │
│  ✅ ナレッジ蓄積       自動生成 + 自動分類（F）                          │
│                                                                          │
│  🆕 エラー自動検索     ログ→関連ドキュメント自動検索（G）               │
│                                                                          │
│  💰 費用: ¥0          全てGemini 3.0無料ティアで実現                    │
│                                                                          │
│  📏 品質: Kent Beck   CC≤10, CoC≤15, TDD                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# 11. JIRA REST API v3 詳細設計

## 11.1 API概要

> **公式ドキュメント**: https://developer.atlassian.com/cloud/jira/platform/rest/v3/

### 認証方式

| 方式 | 用途 | 推奨 |
|------|------|------|
| **API Token** | 個人開発/テスト | ⭐ MVP |
| **OAuth 2.0** | 本番アプリ | 将来 |
| **Connect App** | Atlassian Marketplace | × |

```typescript
// API Token認証ヘッダー
const headers = {
  'Authorization': `Basic ${Buffer.from(`${email}:${apiToken}`).toString('base64')}`,
  'Accept': 'application/json',
  'Content-Type': 'application/json'
};
```

## 11.2 主要エンドポイント

### Issue作成 (POST /rest/api/3/issue)

```typescript
// src/shared/clients/jira-client.ts
interface CreateIssueParams {
  projectKey: string;
  issueType: 'Bug' | 'Task' | 'Story';
  summary: string;
  description: string;
  priority?: 'Highest' | 'High' | 'Medium' | 'Low' | 'Lowest';
  assignee?: string;
  labels?: string[];
}

async function createIssue(params: CreateIssueParams): Promise<JiraIssue> {
  const url = `https://${domain}.atlassian.net/rest/api/3/issue`;
  
  const body = {
    fields: {
      project: { key: params.projectKey },
      issuetype: { name: params.issueType },
      summary: params.summary,
      description: {
        type: 'doc',
        version: 1,
        content: [
          {
            type: 'paragraph',
            content: [{ type: 'text', text: params.description }]
          }
        ]
      },
      priority: params.priority ? { name: params.priority } : undefined,
      assignee: params.assignee ? { accountId: params.assignee } : undefined,
      labels: params.labels ?? []
    }
  };
  
  const response = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify(body)
  });
  
  return response.json();
}
```

### JQL検索 (GET /rest/api/3/search)

```typescript
interface SearchParams {
  jql: string;
  startAt?: number;
  maxResults?: number;
  fields?: string[];
}

async function searchIssues(params: SearchParams): Promise<SearchResult> {
  const queryParams = new URLSearchParams({
    jql: params.jql,
    startAt: String(params.startAt ?? 0),
    maxResults: String(params.maxResults ?? 50),
    fields: (params.fields ?? ['summary', 'status', 'priority']).join(',')
  });
  
  const url = `https://${domain}.atlassian.net/rest/api/3/search?${queryParams}`;
  
  const response = await fetch(url, { headers });
  return response.json();
}

// JQL例
const jql = `
  project = "FIC" 
  AND status NOT IN (Done, Closed) 
  AND text ~ "PostgreSQL connection"
  ORDER BY created DESC
`;
```

### コメント追加 (POST /rest/api/3/issue/{issueKey}/comment)

```typescript
async function addComment(issueKey: string, body: string): Promise<void> {
  const url = `https://${domain}.atlassian.net/rest/api/3/issue/${issueKey}/comment`;
  
  await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      body: {
        type: 'doc',
        version: 1,
        content: [
          {
            type: 'paragraph',
            content: [{ type: 'text', text: body }]
          }
        ]
      }
    })
  });
}
```

## 11.3 レート制限

| プラン | レート制限 |
|--------|----------|
| Free | 100 requests/min |
| Standard | 100 requests/min |
| Premium | 100 requests/min |

**対策**: リクエストバッチング + 指数バックオフ

---

# 12. Confluence REST API v2 詳細設計

## 12.1 API概要

> **公式ドキュメント**: https://developer.atlassian.com/cloud/confluence/rest/v2/

### 認証（JIRA共通）

```typescript
// JIRA と同じ API Token 認証
const headers = {
  'Authorization': `Basic ${Buffer.from(`${email}:${apiToken}`).toString('base64')}`,
  'Accept': 'application/json'
};
```

## 12.2 主要エンドポイント

### CQL検索 (GET /wiki/rest/api/content/search)

```typescript
interface ConfluenceSearchParams {
  cql: string;
  limit?: number;
  start?: number;
  expand?: string[];
}

async function searchContent(params: ConfluenceSearchParams): Promise<SearchResult> {
  const queryParams = new URLSearchParams({
    cql: params.cql,
    limit: String(params.limit ?? 25),
    start: String(params.start ?? 0),
    expand: (params.expand ?? ['body.storage', 'version']).join(',')
  });
  
  const url = `https://${domain}.atlassian.net/wiki/rest/api/content/search?${queryParams}`;
  
  const response = await fetch(url, { headers });
  return response.json();
}
```

### CQL (Confluence Query Language) 構文

```typescript
// CQL例
const cqlExamples = {
  // テキスト検索
  fullText: 'text ~ "PostgreSQL トラブルシューティング"',
  
  // スペースフィルター
  bySpace: 'space = "DEV" AND text ~ "API"',
  
  // ラベルフィルター
  byLabel: 'label = "runbook" AND text ~ "障害対応"',
  
  // 更新日フィルター
  byDate: 'lastModified > "2026-01-01" AND type = page',
  
  // 複合条件
  complex: `
    space IN ("DEV", "OPS") 
    AND type = page 
    AND label IN ("runbook", "guide")
    AND text ~ "PostgreSQL"
    ORDER BY lastModified DESC
  `
};
```

### ページ内容取得 (GET /wiki/rest/api/content/{id})

```typescript
interface GetPageParams {
  pageId: string;
  expand?: ('body.storage' | 'body.view' | 'version' | 'ancestors')[];
}

async function getPage(params: GetPageParams): Promise<ConfluencePage> {
  const queryParams = new URLSearchParams({
    expand: (params.expand ?? ['body.storage']).join(',')
  });
  
  const url = `https://${domain}.atlassian.net/wiki/rest/api/content/${params.pageId}?${queryParams}`;
  
  const response = await fetch(url, { headers });
  return response.json();
}

// レスポンス例
interface ConfluencePage {
  id: string;
  title: string;
  body: {
    storage: {
      value: string;  // HTML形式
    };
  };
  version: {
    number: number;
  };
  _links: {
    webui: string;
  };
}
```

## 12.3 HTMLからプレーンテキスト変換

```typescript
import { JSDOM } from 'jsdom';

function htmlToPlainText(html: string): string {
  const dom = new JSDOM(html);
  return dom.window.document.body.textContent ?? '';
}

// RAG用にチャンク分割
function chunkText(text: string, chunkSize: number = 1000): string[] {
  const sentences = text.split(/[。.!?]/);
  const chunks: string[] = [];
  let currentChunk = '';
  
  for (const sentence of sentences) {
    if (currentChunk.length + sentence.length > chunkSize) {
      chunks.push(currentChunk.trim());
      currentChunk = sentence;
    } else {
      currentChunk += sentence;
    }
  }
  
  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }
  
  return chunks;
}
```

---

# 13. RAG (Retrieval Augmented Generation) 詳細設計

## 13.1 アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           RAG システム構成                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [インデックス作成パイプライン]                                              │
│                                                                              │
│  JIRA/Confluence ──→ Document Loader ──→ Text Splitter ──→ Embeddings      │
│                                               │                              │
│                                               ▼                              │
│                                        ┌─────────────┐                      │
│                                        │ Supabase    │                      │
│                                        │ pgvector    │                      │
│                                        └─────────────┘                      │
│                                               │                              │
│  [検索パイプライン]                            │                              │
│                                               ▼                              │
│  ユーザークエリ ──→ Query Embedding ──→ Similarity Search ──→ Top-K結果    │
│                                                                    │         │
│                                                                    ▼         │
│                                              ┌─────────────────────────────┐│
│                                              │ LLM (Gemini) + Context      ││
│                                              │ → 回答生成                   ││
│                                              └─────────────────────────────┘│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 13.2 Supabase pgvector セットアップ

```sql
-- Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Create documents table
CREATE TABLE documents (
  id BIGSERIAL PRIMARY KEY,
  content TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  embedding VECTOR(768),  -- Gemini embeddings dimension
  source_type VARCHAR(50),  -- 'jira', 'confluence', 'teams'
  source_id VARCHAR(255),   -- Original document ID
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create index for similarity search
CREATE INDEX ON documents USING ivfflat (embedding vector_cosine_ops)
  WITH (lists = 100);

-- Create similarity search function
CREATE OR REPLACE FUNCTION match_documents (
  query_embedding VECTOR(768),
  match_count INT DEFAULT 5,
  filter JSONB DEFAULT '{}'
) RETURNS TABLE (
  id BIGINT,
  content TEXT,
  metadata JSONB,
  source_type VARCHAR(50),
  source_id VARCHAR(255),
  similarity FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.content,
    d.metadata,
    d.source_type,
    d.source_id,
    1 - (d.embedding <=> query_embedding) AS similarity
  FROM documents d
  WHERE d.metadata @> filter
  ORDER BY d.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Create keyword search function (hybrid search)
CREATE OR REPLACE FUNCTION kw_match_documents(
  query_text TEXT,
  match_count INT DEFAULT 5
) RETURNS TABLE (
  id BIGINT,
  content TEXT,
  metadata JSONB,
  similarity REAL
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.content,
    d.metadata,
    ts_rank(to_tsvector('japanese', d.content), plainto_tsquery('japanese', query_text)) AS similarity
  FROM documents d
  WHERE to_tsvector('japanese', d.content) @@ plainto_tsquery('japanese', query_text)
  ORDER BY similarity DESC
  LIMIT match_count;
END;
$$;
```

## 13.3 LangChain.js 実装

```typescript
// src/shared/rag/vector-store.ts
import { SupabaseVectorStore } from '@langchain/community/vectorstores/supabase';
import { GoogleGenerativeAIEmbeddings } from '@langchain/google-genai';
import { createClient } from '@supabase/supabase-js';
import { Document } from '@langchain/core/documents';

// Embeddings設定
const embeddings = new GoogleGenerativeAIEmbeddings({
  apiKey: process.env.GEMINI_API_KEY,
  modelName: 'text-embedding-004',  // 768 dimensions
});

// Supabase クライアント
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

// Vector Store初期化
const vectorStore = new SupabaseVectorStore(embeddings, {
  client: supabase,
  tableName: 'documents',
  queryName: 'match_documents',
});

// ドキュメント追加
export async function indexDocuments(docs: Document[]): Promise<void> {
  await vectorStore.addDocuments(docs);
}

// 類似検索
export async function similaritySearch(
  query: string,
  k: number = 5,
  filter?: Record<string, unknown>
): Promise<Document[]> {
  return vectorStore.similaritySearch(query, k, filter);
}
```

### インデックス作成パイプライン

```typescript
// src/plugins/knowledge-search/indexer.ts
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { Document } from '@langchain/core/documents';

const textSplitter = new RecursiveCharacterTextSplitter({
  chunkSize: 1000,
  chunkOverlap: 200,
  separators: ['\n\n', '\n', '。', '．', '.', ' '],
});

// Confluenceページをインデックス
export async function indexConfluencePage(page: ConfluencePage): Promise<void> {
  const plainText = htmlToPlainText(page.body.storage.value);
  const chunks = await textSplitter.createDocuments(
    [plainText],
    [{
      source_type: 'confluence',
      source_id: page.id,
      title: page.title,
      url: page._links.webui,
    }]
  );
  
  await indexDocuments(chunks);
}

// JIRAチケットをインデックス
export async function indexJiraIssue(issue: JiraIssue): Promise<void> {
  const content = `
    ${issue.fields.summary}
    
    ${issue.fields.description ?? ''}
    
    コメント:
    ${issue.fields.comment?.comments?.map(c => c.body).join('\n') ?? ''}
  `;
  
  const chunks = await textSplitter.createDocuments(
    [content],
    [{
      source_type: 'jira',
      source_id: issue.key,
      status: issue.fields.status.name,
      priority: issue.fields.priority?.name,
    }]
  );
  
  await indexDocuments(chunks);
}
```

## 13.4 検索と回答生成

```typescript
// src/plugins/knowledge-search/searcher.ts
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

export async function searchAndAnswer(query: string): Promise<SearchAnswer> {
  // 1. 類似ドキュメント検索
  const docs = await similaritySearch(query, 5);
  
  // 2. コンテキスト構築
  const context = docs.map((doc, i) => 
    `[ソース ${i + 1}: ${doc.metadata.source_type}/${doc.metadata.source_id}]\n${doc.pageContent}`
  ).join('\n\n---\n\n');
  
  // 3. Gemini で回答生成
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  
  const prompt = `
以下のコンテキストに基づいて質問に回答してください。
回答には必ずソースを引用してください。

## コンテキスト
${context}

## 質問
${query}

## 回答フォーマット
- 明確で簡潔な回答
- 参照元のソース番号を明記
- 情報が見つからない場合は正直に伝える
`;

  const result = await model.generateContent(prompt);
  const answer = result.response.text();
  
  return {
    answer,
    sources: docs.map(doc => ({
      type: doc.metadata.source_type,
      id: doc.metadata.source_id,
      title: doc.metadata.title,
      url: doc.metadata.url,
    })),
  };
}
```

---

# 14. Project-K AI (PR自動レビュー) 詳細設計

## 14.1 アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Project-K AI アーキテクチャ                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [GitHub]                                                                    │
│  PR作成/更新 ──→ Webhook (pull_request event)                               │
│                       │                                                      │
│                       ▼                                                      │
│  [GitHub Actions]                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  1. Checkout ──→ 2. Get Changed Files ──→ 3. AI Review ──→ 4. Post      ││
│  │                                                                          ││
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐        ││
│  │  │ actions/   │  │ Get diff   │  │ Gemini API │  │ createReview│        ││
│  │  │ checkout   │  │ listFiles  │  │ + ESLint   │  │ API         │        ││
│  │  └────────────┘  └────────────┘  └────────────┘  └────────────┘        ││
│  │                                                                          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 14.2 GitHub Actions ワークフロー

```yaml
# .github/workflows/Project-K-review.yml
name: Project-K AI - PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Get changed files
        id: changed-files
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const changedFiles = files
              .filter(f => f.filename.match(/\.(ts|tsx|js|jsx)$/))
              .map(f => ({
                filename: f.filename,
                patch: f.patch,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
              }));
            
            return changedFiles;

      - name: Run ESLint complexity check
        id: eslint-check
        run: |
          npx eslint --format json --output-file eslint-report.json \
            $(echo '${{ steps.changed-files.outputs.result }}' | jq -r '.[].filename' | tr '\n' ' ') \
            || true
          
          echo "report=$(cat eslint-report.json | jq -c)" >> $GITHUB_OUTPUT

      - name: AI Code Review
        id: ai-review
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const { GoogleGenerativeAI } = require('@google/generative-ai');
            
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
            const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
            
            const changedFiles = ${{ steps.changed-files.outputs.result }};
            const eslintReport = ${{ steps.eslint-check.outputs.report }};
            
            const reviews = [];
            
            for (const file of changedFiles) {
              if (!file.patch) continue;
              
              const prompt = `
              あなたはシニアソフトウェアエンジニアです。以下のコード差分をレビューしてください。
              
              ## ファイル: ${file.filename}
              
              ## 差分:
              \`\`\`diff
              ${file.patch}
              \`\`\`
              
              ## ESLint結果:
              ${JSON.stringify(eslintReport.filter(r => r.filePath.includes(file.filename)), null, 2)}
              
              ## レビュー観点:
              1. バグやロジックエラー
              2. セキュリティ問題（SQLインジェクション、XSS等）
              3. パフォーマンス問題
              4. コード品質（複雑度、可読性）
              5. ベストプラクティス違反
              
              ## 出力形式 (JSON):
              {
                "summary": "全体的なコメント",
                "issues": [
                  {
                    "line": 行番号,
                    "severity": "critical|warning|suggestion",
                    "message": "指摘内容",
                    "suggestion": "修正提案（あれば）"
                  }
                ]
              }
              `;
              
              const result = await model.generateContent({
                contents: prompt,
                generationConfig: {
                  responseMimeType: 'application/json',
                }
              });
              
              const review = JSON.parse(result.response.text());
              reviews.push({ file: file.filename, ...review });
            }
            
            return reviews;

      - name: Post review comments
        uses: actions/github-script@v7
        with:
          script: |
            const reviews = ${{ steps.ai-review.outputs.result }};
            
            // 全体サマリーコメント
            const summaries = reviews.map(r => 
              `### ${r.file}\n${r.summary}`
            ).join('\n\n');
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: `## 🤖 Project-K AI レビュー\n\n${summaries}`,
              event: 'COMMENT',
              comments: reviews.flatMap(r => 
                r.issues
                  .filter(i => i.line)
                  .map(i => ({
                    path: r.file,
                    line: i.line,
                    body: `**${i.severity}**: ${i.message}\n\n${i.suggestion ? `💡 提案: ${i.suggestion}` : ''}`
                  }))
              )
            });
```

## 14.3 Gemini API 構造化出力

```typescript
// src/Project-K/review-schema.ts
interface ReviewResponse {
  summary: string;
  issues: ReviewIssue[];
}

interface ReviewIssue {
  line: number;
  severity: 'critical' | 'warning' | 'suggestion';
  message: string;
  suggestion?: string;
}

// Gemini JSON モード設定
const generationConfig = {
  responseMimeType: 'application/json',
  responseSchema: {
    type: 'object',
    properties: {
      summary: { type: 'string' },
      issues: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            line: { type: 'number' },
            severity: { 
              type: 'string',
              enum: ['critical', 'warning', 'suggestion']
            },
            message: { type: 'string' },
            suggestion: { type: 'string' }
          },
          required: ['line', 'severity', 'message']
        }
      }
    },
    required: ['summary', 'issues']
  }
};
```

## 14.4 Gemini API レート制限と無料枠

| モデル | RPM | TPM | RPD |
|--------|-----|---------|-----|
| **gemini-2.0-flash** | 15 | 1,000,000 | 200 |
| gemini-2.5-flash | 10 | 250,000 | 250 |
| gemini-2.5-pro | 2 | 125,000 | 50 |

**推奨**: `gemini-2.0-flash` (最も緩いレート制限)

```typescript
// レート制限対策: 指数バックオフ
async function callWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (error.status === 429 && i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
  throw new Error('Max retries exceeded');
}
```

---

# 15. A. チケット自動化プラグイン詳細設計

## 15.1 処理フロー

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    A. チケット自動化 処理フロー                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [入力]                                                                      │
│  Teams/Slack メッセージ                                                      │
│  「認証画面でログインボタン押しても反応しない」                               │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────┐                                                        │
│  │ 1. 意図分類      │ ← Gemini: バグ報告 / 機能要望 / 質問                  │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 2. 情報抽出      │ ← 対象機能、症状、再現手順                            │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 3. 優先度推定    │ ← 緊急度キーワード分析                                 │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 4. 担当者推薦    │ ← 過去チケット + コンポーネント分析                    │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 5. 下書き生成    │ ← JIRAテンプレート適用                                 │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  [出力]                                                                      │
│  Teams Adaptive Card (確認用)                                                │
│  → 人間が確認・編集 → [起票] or [キャンセル]                                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 15.2 Gemini プロンプト設計

```typescript
// src/plugins/ticket-automation/prompts.ts

const classifyIntentPrompt = `
あなたは開発チームのサポートAIです。
ユーザーのメッセージを分類してください。

## 入力
${userMessage}

## 分類カテゴリ
- bug: 既存機能のバグ報告
- feature: 新機能の要望
- improvement: 既存機能の改善要望
- question: 質問・問い合わせ
- other: その他

## 出力 (JSON)
{
  "category": "bug|feature|improvement|question|other",
  "confidence": 0.0-1.0,
  "reasoning": "分類理由"
}
`;

const extractInfoPrompt = `
バグ報告メッセージから情報を抽出してください。

## 入力
${userMessage}

## 出力 (JSON)
{
  "summary": "1行サマリー（50文字以内）",
  "component": "対象機能・画面",
  "symptom": "症状の説明",
  "reproductionSteps": ["手順1", "手順2", ...],
  "expectedBehavior": "期待動作",
  "actualBehavior": "実際の動作",
  "severity": "critical|high|medium|low",
  "keywords": ["関連キーワード"]
}
`;

const suggestAssigneePrompt = `
以下のバグに対して、過去のチケット履歴から適切な担当者を推薦してください。

## バグ情報
${JSON.stringify(bugInfo)}

## 過去の類似チケット
${JSON.stringify(similarTickets)}

## 出力 (JSON)
{
  "primaryAssignee": {
    "accountId": "ユーザーID",
    "displayName": "表示名",
    "reason": "推薦理由"
  },
  "backupAssignees": [...]
}
`;
```

## 15.3 JIRAチケットテンプレート

```typescript
// src/plugins/ticket-automation/templates.ts

const bugTemplate = {
  fields: {
    project: { key: '${projectKey}' },
    issuetype: { name: 'Bug' },
    summary: '[${component}] ${summary}',
    description: {
      type: 'doc',
      version: 1,
      content: [
        {
          type: 'heading',
          attrs: { level: 2 },
          content: [{ type: 'text', text: '現象' }]
        },
        {
          type: 'paragraph',
          content: [{ type: 'text', text: '${symptom}' }]
        },
        {
          type: 'heading',
          attrs: { level: 2 },
          content: [{ type: 'text', text: '再現手順' }]
        },
        {
          type: 'orderedList',
          content: '${reproductionSteps.map(step => ({ type: "listItem", content: [{ type: "paragraph", content: [{ type: "text", text: step }] }] }))}'
        },
        {
          type: 'heading',
          attrs: { level: 2 },
          content: [{ type: 'text', text: '期待動作' }]
        },
        {
          type: 'paragraph',
          content: [{ type: 'text', text: '${expectedBehavior}' }]
        },
        {
          type: 'heading',
          attrs: { level: 2 },
          content: [{ type: 'text', text: '実際の動作' }]
        },
        {
          type: 'paragraph',
          content: [{ type: 'text', text: '${actualBehavior}' }]
        }
      ]
    },
    priority: { name: '${priority}' },
    labels: '${keywords}',
    assignee: { accountId: '${assigneeId}' }
  }
};
```

---

# 16. B. ナレッジ検索プラグイン詳細設計

## 16.1 検索戦略（ハイブリッド検索）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    B. ナレッジ検索 ハイブリッド戦略                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ユーザークエリ: 「API追加のルールどこ？」                                   │
│       │                                                                      │
│       ├──────────────────┬──────────────────┬──────────────────┐            │
│       ▼                  ▼                  ▼                  ▼            │
│  ┌─────────┐       ┌─────────┐       ┌─────────┐       ┌─────────┐         │
│  │ Vector  │       │ Keyword │       │ JQL     │       │ CQL     │         │
│  │ Search  │       │ Search  │       │ Search  │       │ Search  │         │
│  │(pgvector)│      │(tsvector)│      │ (JIRA)  │       │(Confluence)│       │
│  └────┬────┘       └────┬────┘       └────┬────┘       └────┬────┘         │
│       │                 │                 │                 │               │
│       └─────────────────┴─────────────────┴─────────────────┘               │
│                                   │                                          │
│                                   ▼                                          │
│                          ┌──────────────┐                                   │
│                          │ Result Merger │ ← RRF (Reciprocal Rank Fusion)   │
│                          └──────┬───────┘                                   │
│                                 │                                            │
│                                 ▼                                            │
│                          ┌──────────────┐                                   │
│                          │ LLM Reranker │ ← Gemini で関連度再評価           │
│                          └──────┬───────┘                                   │
│                                 │                                            │
│                                 ▼                                            │
│                          ┌──────────────┐                                   │
│                          │ Answer Gen   │ ← 最終回答生成                    │
│                          └──────────────┘                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 16.2 RRF (Reciprocal Rank Fusion) 実装

```typescript
// src/plugins/knowledge-search/merger.ts

interface SearchResult {
  id: string;
  content: string;
  source: 'vector' | 'keyword' | 'jira' | 'confluence';
  score: number;
  metadata: Record<string, unknown>;
}

function reciprocalRankFusion(
  resultSets: SearchResult[][],
  k: number = 60
): SearchResult[] {
  const scores = new Map<string, number>();
  const results = new Map<string, SearchResult>();
  
  for (const resultSet of resultSets) {
    resultSet.forEach((result, rank) => {
      const currentScore = scores.get(result.id) ?? 0;
      scores.set(result.id, currentScore + 1 / (k + rank + 1));
      
      if (!results.has(result.id)) {
        results.set(result.id, result);
      }
    });
  }
  
  return Array.from(results.values())
    .map(result => ({
      ...result,
      score: scores.get(result.id)!
    }))
    .sort((a, b) => b.score - a.score);
}
```

## 16.3 検索エンドポイント

```typescript
// src/plugins/knowledge-search/index.ts

export async function searchKnowledge(query: string): Promise<KnowledgeAnswer> {
  // 1. 並列検索
  const [vectorResults, keywordResults, jiraResults, confluenceResults] = await Promise.all([
    similaritySearch(query, 10),
    keywordSearch(query, 10),
    searchJira(`text ~ "${query}"`, 10),
    searchConfluence(`text ~ "${query}"`, 10),
  ]);
  
  // 2. RRFで統合
  const merged = reciprocalRankFusion([
    vectorResults.map(toSearchResult),
    keywordResults.map(toSearchResult),
    jiraResults.map(toSearchResult),
    confluenceResults.map(toSearchResult),
  ]);
  
  // 3. Top-K選択
  const topK = merged.slice(0, 5);
  
  // 4. 回答生成
  const answer = await generateAnswer(query, topK);
  
  return {
    answer: answer.text,
    sources: topK.map(r => ({
      type: r.source,
      id: r.metadata.id as string,
      title: r.metadata.title as string,
      url: r.metadata.url as string,
      snippet: r.content.slice(0, 200),
    })),
    confidence: answer.confidence,
  };
}
```

---

**設計書作成日**: 2026年2月5日  
**更新日**: 2026年2月5日（JIRA/Confluence API + RAG + Project-K AI + プラグイン詳細設計追加）  
**レビュアー**: Andrej Karpathy視点 + Kent Beck TDD視点  
**参考文献**:
- Atlassian JIRA REST API v3: https://developer.atlassian.com/cloud/jira/platform/rest/v3/
- Atlassian Confluence REST API v2: https://developer.atlassian.com/cloud/confluence/rest/v2/
- LangChain.js: https://js.langchain.com/
- Google Gemini API: https://ai.google.dev/
- Supabase pgvector: https://supabase.com/docs/guides/ai
- GitHub Actions: https://docs.github.com/en/actions
